{
  "name": "core",
  "description": "",
  "files": [
    {
      "path": "core/test.py",
      "name": "test.py",
      "description": "",
      "codeBlocks": [
        {
          "id": "block_5b76a1d9",
          "type": "code",
          "content": "# TIMING TEST - 2025-07-06T21:25:07.164Z\n# This should appear in GitHub immediately\n# No more lag!",
          "language": "python",
          "description": "Main content of core/test.py",
          "order": 0,
          "file": "core/test.py",
          "meta": {
            "segmentType": "other",
            "startLine": 1,
            "endLine": 3
          }
        }
      ]
    },
    {
      "path": "core/types.ts",
      "name": "types.ts",
      "description": "",
      "codeBlocks": [
        {
          "id": "block_5d3cd207",
          "type": "code",
          "content": "// try\n// and try again\n// one last times\nexport interface UserProfile {\n  firstName: string;\n  lastName: string;\n  avatar?: string;\n  bio?: string;\n  location?: string;\n  socialLinks?: {\n    twitter?: string;\n    github?: string;\n    linkedin?: string;\n  };\n}",
          "language": "typescript",
          "description": "block 1 description...",
          "order": 0,
          "file": "core/types.ts",
          "meta": {
            "segmentType": "comment",
            "startLine": 1,
            "endLine": 15
          }
        },
        {
          "id": "block_491c476c",
          "type": "code",
          "content": "<<<<<<< HEAD\nexport type UserRole = 'admin' | 'user' | 'moderator';\n// #endregion\n\n// #region Authentication Types\nexport interface AuthState {\n  isAuthenticated: boolean;\n  user: User | null;\n  token: string | null;\n  loading: boolean;\n  error: string | null;\n}\n\nexport interface LoginCredentials {\n  username: string;\n  password: string;\n  remember?: boolean;\n}\n\nexport interface RegistrationData extends LoginCredentials {\n  email: string;\n  confirmPassword: string;\n}\n// #endregion\n\n// #region API Types\nexport interface ApiResponse<T> {\n  success: boolean;\n  data?: T;\n  error?: {\n    code: string;\n    message: string;\n    details?: unknown;\n  };\n}\n\nexport interface PaginatedResponse<T> extends ApiResponse<T[]> {\n  pagination: {\n    total: number;\n    page: number;\n    pageSize: number;\n    totalPages: number;\n  };\n}\n// #endregion\n\n// Game Types and Interfaces for Tic-Tac-Toe\n\nexport type Player = 'X' | 'O';\nexport type CellValue = Player | null;\nexport type Board = CellValue[];\n\nexport interface GameState {\n  board: Board;\n  currentPlayer: Player;\n  winner: Player | null;\n  isDraw: boolean;\n  isGameOver: boolean;\n  gameMode: GameMode;\n  moveCount: number;\n}\n\nexport type GameMode = 'ai' | 'player' | 'menu';\n\nexport interface GameStats {\n  gamesPlayed: number;\n  wins: number;\n  losses: number;\n  draws: number;\n  winRate: number;\n}\n\nexport interface Move {\n  index: number;\n  player: Player;\n}\n\nexport interface GameConfig {\n  aiDifficulty: 'easy' | 'medium' | 'hard';\n  firstPlayer: Player;\n}\n\nexport interface WinningLine {\n  indices: number[];\n  pattern: 'row' | 'column' | 'diagonal';\n}\n\n// AI Types\nexport interface AIMove {\n  index: number;\n  score: number;\n}\n\nexport interface GameContextType {\n  gameState: GameState;\n  stats: GameStats;\n  makeMove: (index: number) => void;\n  resetGame: () => void;\n  setGameMode: (mode: GameMode) => void;\n  newGame: (mode: GameMode) => void;\n}\n\n// UI Component Props\nexport interface SquareProps {\n  value: CellValue;\n  onClick: () => void;\n  isWinning?: boolean;\n  disabled?: boolean;\n}\n\nexport interface BoardProps {\n  board: Board;\n  onSquareClick: (index: number) => void;\n  winningLine?: number[];\n  disabled?: boolean;\n}\n\nexport interface GameInfoProps {\n  currentPlayer: Player;\n  winner: Player | null;\n  isDraw: boolean;\n  gameMode: GameMode;\n  moveCount: number;\n}\n\nexport interface GameMenuProps {\n  onModeSelect: (mode: GameMode) => void;\n  stats: GameStats;\n}\n\nexport interface StatsDisplayProps {\n  stats: GameStats;\n}\n\n// Constants\nexport const INITIAL_BOARD: Board = Array(9).fill(null);\n\nexport const WINNING_COMBINATIONS: number[][] = [\n  [0, 1, 2], // top row\n  [3, 4, 5], // middle row\n  [6, 7, 8], // bottom row\n  [0, 3, 6], // left column\n  [1, 4, 7], // middle column\n  [2, 5, 8], // right column\n  [0, 4, 8], // diagonal top-left to bottom-right\n  [2, 4, 6], // diagonal top-right to bottom-left\n];\n\nexport const INITIAL_GAME_STATE: GameState = {\n  board: INITIAL_BOARD,\n  currentPlayer: 'X',\n  winner: null,\n  isDraw: false,\n  isGameOver: false,\n  gameMode: 'menu',\n  moveCount: 0,\n};\n\nexport const INITIAL_STATS: GameStats = {\n  gamesPlayed: 0,\n  wins: 0,\n  losses: 0,\n  draws: 0,\n  winRate: 0,\n}; \n=======\n85\n>>>>>>> 9228db559405d0bcf1ff3e8daf4b4a36c5f738af",
          "language": "typescript",
          "description": "Code block 2",
          "order": 1,
          "file": "core/types.ts",
          "meta": {
            "segmentType": "other",
            "startLine": 18,
            "endLine": 185
          }
        }
      ]
    },
    {
      "path": "core/auth/login.ts",
      "name": "login.ts",
      "description": "",
      "codeBlocks": [
        {
          "id": "block_80b79ada",
          "type": "code",
          "content": "// Type definitions for authentication\ninterface Credentials {\n  username: string;\n  password: string;\n}\n\n//MY FIRST EDIT\ninterface AuthResponse {\n  token: string;\n  user: User;\n}\n\n//good here\ninterface User {\n  id: string;\n  username: string;\n  email: string;\n  roles: string[];\n}\n\n//725\n//next day\n//438",
          "language": "typescript",
          "description": "Main content of core/auth/login.ts",
          "order": 0,
          "file": "core/auth/login.ts",
          "meta": {
            "segmentType": "other",
            "startLine": 1,
            "endLine": 23
          }
        }
      ]
    },
    {
      "path": "core/auth/session.ts",
      "name": "session.ts",
      "description": "",
      "codeBlocks": [
        {
          "id": "block_428efdd7",
          "type": "code",
          "content": "const USER_KEY = 'user_data';\n//85\n\nexport function saveSession(token: string, user: any): void {\n  localStorage.setItem(TOKEN_KEY, token);\n  localStorage.setItem(USER_KEY, JSON.stringify(user));\n}\n//good ehre\n\nexport function clearSession(): void {\n  localStorage.removeItem(TOKEN_KEY);\n  localStorage.removeItem(USER_KEY);\n}\n//8\n\nconst TOKEN_KEY = 'auth_token';",
          "language": "typescript",
          "description": "Main content of core/auth/session.ts",
          "order": 0,
          "file": "core/auth/session.ts",
          "meta": {
            "segmentType": "other",
            "startLine": 1,
            "endLine": 16
          }
        }
      ]
    },
    {
      "path": "core/auth/providers/oauth.ts",
      "name": "oauth.ts",
      "description": "",
      "codeBlocks": [
        {
          "id": "block_798f0ccf",
          "type": "code",
          "content": "new shit to dow 911\n950\n\nfanskldfnsadl;kfn;;sal",
          "language": "typescript",
          "description": "Main content of core/auth/providers/oauth.ts",
          "order": 0,
          "file": "core/auth/providers/oauth.ts",
          "meta": {
            "segmentType": "other",
            "startLine": 1,
            "endLine": 4
          }
        }
      ]
    },
    {
      "path": "core/game/ai.ts",
      "name": "ai.ts",
      "description": "",
      "codeBlocks": [
        {
          "id": "block_551cf78f",
          "type": "code",
          "content": "---\nid: 2b5baa18-2b5b-2b5b-2b5b-2b5baa18\npath: core/game/ai.ts\nlevel: file\ntitle: \"Ai\"\ndescription: \"TypeScript module\"\n---",
          "language": "typescript",
          "description": "Code block 1",
          "order": 0,
          "file": "core/game/ai.ts",
          "meta": {
            "segmentType": "other",
            "startLine": 1,
            "endLine": 7
          }
        },
        {
          "id": "block_0bbb22d8",
          "type": "code",
          "content": "* Evaluate the current board position\n * @param board Current board state\n * @param aiPlayer AI player symbol\n * @returns Score evaluation\n */\n//test\nexport const evaluateBoard = (board: Board, aiPlayer: Player): number => {\n  const humanPlayer = aiPlayer === 'X' ? 'O' : 'X';\n  const winner = checkWinner(board);\n  \n  if (winner === aiPlayer) return 10;\n  if (winner === humanPlayer) return -10;\n  if (checkDraw(board)) return 0;\n  \n  // Evaluate position based on potential winning lines\n  let score = 0;\n  const combinations = [\n    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows\n    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns\n    [0, 4, 8], [2, 4, 6] // diagona",
          "language": "typescript",
          "description": "Code block 2",
          "order": 1,
          "file": "core/game/ai.ts",
          "meta": {
            "segmentType": "other",
            "startLine": 10,
            "endLine": 29
          }
        }
      ]
    },
    {
      "path": "core/game/logic.ts",
      "name": "logic.ts",
      "description": "",
      "codeBlocks": [
        {
          "id": "block_8707b13b",
          "type": "code",
          "content": "---\nid: 4b3401e4-4b34-4b34-4b34-4b3401e4\npath: core/game/logic.ts\nlevel: file\ntitle: \"Logic\"\ndescription: \"TypeScript module\"\n---\n//test\n// Core Game Logic for Tic-Tac-Toe\n\nimport {\n  Board,\n  Player,\n  GameState,\n  CellValue,\n  WINNING_COMBINATIONS,\n  INITIAL_BOARD,\n  Move,\n  WinningLine\n} from '@core/types';\n\n/**\n * Check if there's a winner on the board\n * @param board Current board state\n * @returns Winner player or null if no winner\n */\nexport const checkWinner = (board: Board): Player | null => {\n  for (const combination of WINNING_COMBINATIONS) {\n    const [a, b, c] = combination;\n    if (board[a] && board[a] === board[b] && board[a] === board[c]) {\n      return board[a] as Player;\n    }\n  }\n  return null;\n};\n\n/**\n * Check if the game is a draw (board full with no winner)\n * @param board Current board state\n * @returns True if the game is a draw\n */\nexport const checkDraw = (board: Board): boolean => {\n  return board.every(cell => cell !== null) && !checkWinner(board);\n};\n\n/**\n * Get the winning line indices if there's a winner\n * @param board Current board state\n * @returns Array of winning indices or null\n */\nexport const getWinningLine = (board: Board): number[] | null => {\n  for (const combination of WINNING_COMBINATIONS) {\n    const [a, b, c] = combination;\n    if (board[a] && board[a] === board[b] && board[a] === board[c]) {\n      return combination;\n    }\n  }\n  return null;\n};\n\n/**\n * Make a move on the board\n * @param board Current board state\n * @param index Square index to place the move\n * @param player Player making the move\n * @returns New board state or null if move is invalid\n */\nexport const makeMove = (board: Board, index: number, player: Player): Board | null => {\n  if (index < 0 || index >= 9 || board[index] !== null) {\n    return null; // Invalid move\n  }\n  \n  const newBoard = [...board];\n  newBoard[index] = player;\n  return newBoard;\n};\n\n/**\n * Get available moves (empty squares)\n * @param board Current board state\n * @returns Array of available move indices\n */\nexport const getAvailableMoves = (board: Board): number[] => {\n  return board\n    .map((cell, index) => cell === null ? index : null)\n    .filter(index => index !== null) as number[];\n};\n\n/**\n * Switch to the other player\n * @param currentPlayer Current player\n * @returns Other player\n */\nexport const switchPlayer = (currentPlayer: Player): Player => {\n  return currentPlayer === 'X' ? 'O' : 'X';\n};\n\n/**\n * Check if a move is valid\n * @param board Current board state\n * @param index Square index to check\n * @returns True if the move is valid\n */\nexport const isValidMove = (board: Board, index: number): boolean => {\n  return index >= 0 && index < 9 && board[index] === null;\n};\n\n/**\n * Create a new game state\n * @param gameMode Game mode to set\n * @returns Initial game state\n */\nexport const createNewGameState = (gameMode: 'ai' | 'player' | 'menu' = 'menu'): GameState => {\n  return {\n    board: [...INITIAL_BOARD],\n    currentPlayer: 'X',\n    winner: null,\n    isDraw: false,\n    isGameOver: false,\n    gameMode,\n    moveCount: 0,\n  };\n};\n\n/**\n * Update game state after a move\n * @param gameState Current game state\n * @param moveIndex Index of the move\n * @returns Updated game state\n */\nexport const updateGameState = (gameState: GameState, moveIndex: number): GameState => {\n  const newBoard = makeMove(gameState.board, moveIndex, gameState.currentPlayer);\n  \n  if (!newBoard) {\n    return gameState; // Invalid move, return unchanged state\n  }\n  \n  const winner = checkWinner(newBoard);\n  const isDraw = checkDraw(newBoard);\n  const isGameOver = winner !== null || isDraw;\n  \n  return {\n    ...gameState,\n    board: newBoard,\n    currentPlayer: isGameOver ? gameState.currentPlayer : switchPlayer(gameState.currentPlayer),\n    winner,\n    isDraw,\n    isGameOver,\n    moveCount: gameState.moveCount + 1,\n  };\n};\n\n/**\n * Get game status message\n * @param gameState Current game state\n * @returns Status message string\n */\nexport const getGameStatusMessage = (gameState: GameState): string => {\n  if (gameState.winner) {\n    return `Player ${gameState.winner} wins!`;\n  }\n  \n  if (gameState.isDraw) {\n    return \"It's a draw!\";\n  }\n  \n  if (gameState.gameMode === 'ai' && gameState.currentPlayer === 'O') {\n    return \"AI is thinking...\";\n  }\n  \n  return `Player ${gameState.currentPlayer}'s turn`;\n};\n\n/**\n * Check if it's AI's turn\n * @param gameState Current game state\n * @returns True if it's AI's turn\n */\nexport const isAITurn = (gameState: GameState): boolean => {\n  return gameState.gameMode === 'ai' && \n         gameState.currentPlayer === 'O' && \n         !gameState.isGameOver;\n};\n\n/**\n * Get the pattern type of a winning line\n * @param winningIndices Winning line indices\n * @returns Pattern type\n */\nexport const getWinningPattern = (winningIndices: number[]): 'row' | 'column' | 'diagonal' => {\n  const [a, b, c] = winningIndices.sort((x, y) => x - y);\n  \n  // Check for rows\n  if (Math.floor(a / 3) === Math.floor(b / 3) && Math.floor(b / 3) === Math.floor(c / 3)) {\n    return 'row';\n  }\n  \n  // Check for columns\n  if (a % 3 === b % 3 && b % 3 === c % 3) {\n    return 'column';\n  }\n  \n  // Must be diagonal\n  return 'diagonal';\n};\n\nexport default {\n  checkWinner,\n  checkDraw,\n  getWinningLine,\n  makeMove,\n  getAvailableMoves,\n  switchPlayer,\n  isValidMove,\n  createNewGameState,\n  updateGameState,\n  getGameStatusMessage,\n  isAITurn,\n  getWinningPattern,\n}; ",
          "language": "typescript",
          "description": "Main content of core/game/logic.ts",
          "order": 0,
          "file": "core/game/logic.ts",
          "meta": {
            "segmentType": "other",
            "startLine": 1,
            "endLine": 220
          }
        }
      ]
    },
    {
      "path": "core/game/utils.ts",
      "name": "utils.ts",
      "description": "",
      "codeBlocks": [
        {
          "id": "block_6f9ac3e2",
          "type": "code",
          "content": "// Game Utilities for Tic-Tac-Toe\n\nimport { GameStats, GameState, Player } from '@core/types';\n\n/**\n * Local Storage Keys\n */\nconst STORAGE_KEYS = {\n  GAME_STATS: 'tic-tac-toe-stats',\n  GAME_STATE: 'tic-tac-toe-game-state',\n  SETTINGS: 'tic-tac-toe-settings',\n} as const;\n\n/**\n * Save game statistics to local storage\n * @param stats Game statistics to save\n */\nexport const saveGameStats = (stats: GameStats): void => {\n  try {\n    localStorage.setItem(STORAGE_KEYS.GAME_STATS, JSON.stringify(stats));\n  } catch (error) {\n    console.warn('Failed to save game stats:', error);\n  }\n};\n\n/**\n * Load game statistics from local storage\n * @returns Saved game statistics or default stats\n */\nexport const loadGameStats = (): GameStats => {\n  try {\n    const saved = localStorage.getItem(STORAGE_KEYS.GAME_STATS);\n    if (saved) {\n      const stats = JSON.parse(saved) as GameStats;\n      // Recalculate win rate to ensure accuracy\n      stats.winRate = stats.gamesPlayed > 0 ? (stats.wins / stats.gamesPlayed) * 100 : 0;\n      return stats;\n    }\n  } catch (error) {\n    console.warn('Failed to load game stats:', error);\n  }\n  \n  return {\n    gamesPlayed: 0,\n    wins: 0,\n    losses: 0,\n    draws: 0,\n    winRate: 0,\n  };\n};\n\n/**\n * Update game statistics after a game ends\n * @param currentStats Current statistics\n * @param winner Winner of the game (null for draw)\n * @param gameMode Game mode played\n * @returns Updated statistics\n */\nexport const updateGameStats = (\n  currentStats: GameStats,\n  winner: Player | null,\n  gameMode: 'ai' | 'player'\n): GameStats => {\n  const newStats = { ...currentStats };\n  newStats.gamesPlayed += 1;\n  \n  if (winner === null) {\n    newStats.draws += 1;\n  } else if (winner === 'X') {\n    newStats.wins += 1;\n  } else {\n    newStats.losses += 1;\n  }\n  \n  newStats.winRate = (newStats.wins / newStats.gamesPlayed) * 100;\n  \n  saveGameStats(newStats);\n  return newStats;\n};\n\n/**\n * Reset game statistics\n * @returns Reset statistics\n */\nexport const resetGameStats = (): GameStats => {\n  const resetStats: GameStats = {\n    gamesPlayed: 0,\n    wins: 0,\n    losses: 0,\n    draws: 0,\n    winRate: 0,\n  };\n  \n  saveGameStats(resetStats);\n  return resetStats;\n};\n\n/**\n * Save game state to local storage\n * @param gameState Game state to save\n */\nexport const saveGameState = (gameState: GameState): void => {\n  try {\n    localStorage.setItem(STORAGE_KEYS.GAME_STATE, JSON.stringify(gameState));\n  } catch (error) {\n    console.warn('Failed to save game state:', error);\n  }\n};\n\n/**\n * Load game state from local storage\n * @returns Saved game state or null\n */\nexport const loadGameState = (): GameState | null => {\n  try {\n    const saved = localStorage.getItem(STORAGE_KEYS.GAME_STATE);\n    if (saved) {\n      return JSON.parse(saved) as GameState;\n    }\n  } catch (error) {\n    console.warn('Failed to load game state:', error);\n  }\n  \n  return null;\n};\n\n/**\n * Clear saved game state\n */\nexport const clearSavedGameState = (): void => {\n  try {\n    localStorage.removeItem(STORAGE_KEYS.GAME_STATE);\n  } catch (error) {\n    console.warn('Failed to clear saved game state:', error);\n  }\n};\n\n/**\n * Format game statistics for display\n * @param stats Game statistics\n * @returns Formatted statistics object\n */\nexport const formatGameStats = (stats: GameStats) => {\n  return {\n    gamesPlayed: stats.gamesPlayed.toString(),\n    wins: stats.wins.toString(),\n    losses: stats.losses.toString(),\n    draws: stats.draws.toString(),\n    winRate: stats.winRate.toFixed(1) + '%',\n  };\n};\n\n/**\n * Get game result message\n * @param winner Winner of the game\n * @param gameMode Game mode\n * @returns Result message\n */\nexport const getGameResultMessage = (\n  winner: Player | null,\n  gameMode: 'ai' | 'player'\n): string => {\n  if (winner === null) {\n    return \"It's a draw! ðŸ¤\";\n  }\n  \n  if (gameMode === 'ai') {\n    return winner === 'X' ? \"You won! ðŸŽ‰\" : \"AI won! ðŸ¤–\";\n  }\n  \n  return `Player ${winner} won! ðŸŽ‰`;\n};\n\n/**\n * Get encouraging message based on game result\n * @param winner Winner of the game\n * @param gameMode Game mode\n * @returns Encouraging message\n */\nexport const getEncouragingMessage = (\n  winner: Player | null,\n  gameMode: 'ai' | 'player'\n): string => {\n  if (winner === null) {\n    return \"Great game! Both players played well.\";\n  }\n  \n  if (gameMode === 'ai') {\n    if (winner === 'X') {\n      return \"Excellent strategy! You outplayed the AI.\";\n    } else {\n      return \"Don't give up! Try a different strategy next time.\";\n    }\n  }\n  \n  return `Congratulations Player ${winner}! Well played.`;\n};\n\n/**\n * Generate a random game tip\n * @returns Random game tip\n */\nexport const getRandomGameTip = (): string => {\n  const tips = [\n    \"Try to control the center square - it's the most valuable position!\",\n    \"Look for opportunities to create multiple winning threats at once.\",\n    \"Block your opponent's winning moves before going for your own.\",\n    \"Corners are strong positions - they're part of multiple winning lines.\",\n    \"Watch out for fork opportunities where you can win in two ways.\",\n    \"Don't just focus on offense - defense is just as important!\",\n    \"The first player (X) has a slight advantage if they play optimally.\",\n    \"Try to think one move ahead of your opponent.\",\n  ];\n  \n  return tips[Math.floor(Math.random() * tips.length)];\n};\n\n/**\n * Check if local storage is available\n * @returns True if local storage is available\n */\nexport const isLocalStorageAvailable = (): boolean => {\n  try {\n    const test = '__localStorage_test__';\n    localStorage.setItem(test, 'test');\n    localStorage.removeItem(test);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Debounce function to limit how often a function can be called\n * @param func Function to debounce\n * @param wait Wait time in milliseconds\n * @returns Debounced function\n */\nexport const debounce = <T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): ((...args: Parameters<T>) => void) => {\n  let timeout: number;\n  \n  return (...args: Parameters<T>) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func(...args), wait);\n  };\n};\n\n/**\n * Format time duration in milliseconds to readable format\n * @param ms Time in milliseconds\n * @returns Formatted time string\n */\nexport const formatDuration = (ms: number): string => {\n  const seconds = Math.floor(ms / 1000);\n  const minutes = Math.floor(seconds / 60);\n  \n  if (minutes > 0) {\n    return `${minutes}m ${seconds % 60}s`;\n  }\n  \n  return `${seconds}s`;\n};\n\n/**\n * Create a delay promise\n * @param ms Delay in milliseconds\n * @returns Promise that resolves after the delay\n */\nexport const delay = (ms: number): Promise<void> => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n\nexport default {\n  saveGameStats,\n  loadGameStats,\n  updateGameStats,\n  resetGameStats,\n  saveGameState,\n  loadGameState,\n  clearSavedGameState,\n  formatGameStats,\n  getGameResultMessage,\n  getEncouragingMessage,\n  getRandomGameTip,\n  isLocalStorageAvailable,\n  debounce,\n  formatDuration,\n  delay,\n}; ",
          "language": "typescript",
          "description": "Main content of core/game/utils.ts",
          "order": 0,
          "file": "core/game/utils.ts",
          "meta": {
            "segmentType": "other",
            "startLine": 1,
            "endLine": 292
          }
        }
      ]
    },
    {
      "path": "core/hooks/useGame.ts",
      "name": "useGame.ts",
      "description": "",
      "codeBlocks": [
        {
          "id": "block_4d0970c4",
          "type": "code",
          "content": "// Custom Hook for Game State Management\n\nimport { useState, useEffect, useCallback } from 'react';\nimport {\n  GameState,\n  GameMode,\n  Player,\n  INITIAL_GAME_STATE\n} from '@core/types';\n\nimport {\n  updateGameState,\n  createNewGameState,\n  isAITurn,\n  getWinningLine\n} from '@core/game/logic';\n\nimport { getAIMove } from '@core/game/ai';\nimport {\n  saveGameState,\n  loadGameState,\n  clearSavedGameState\n} from '@core/game/utils';\n\nexport const useGame = () => {\n  const [gameState, setGameState] = useState<GameState>(INITIAL_GAME_STATE);\n  const [isAIThinking, setIsAIThinking] = useState(false);\n\n  // Load saved game state on mount\n  useEffect(() => {\n    const savedState = loadGameState();\n    if (savedState && !savedState.isGameOver) {\n      setGameState(savedState);\n    }\n  }, []);\n\n  // Save game state whenever it changes\n  useEffect(() => {\n    if (gameState.moveCount > 0) {\n      saveGameState(gameState);\n    }\n  }, [gameState]);\n\n  // Handle AI moves\n  useEffect(() => {\n    const makeAIMove = async () => {\n      if (isAITurn(gameState) && !isAIThinking) {\n        setIsAIThinking(true);\n        \n        try {\n          const aiMoveIndex = await getAIMove(gameState.board, 'O', 'hard', 800);\n          \n                     if (aiMoveIndex !== -1) {\n             setGameState((prevState: GameState) => updateGameState(prevState, aiMoveIndex));\n           }\n        } catch (error) {\n          console.error('AI move failed:', error);\n        } finally {\n          setIsAIThinking(false);\n        }\n      }\n    };\n\n    makeAIMove();\n  }, [gameState, isAIThinking]);\n\n  /**\n   * Make a move at the specified index\n   */\n  const makeMove = useCallback((index: number) => {\n    if (\n      gameState.isGameOver ||\n      gameState.board[index] !== null ||\n      isAIThinking ||\n      (gameState.gameMode === 'ai' && gameState.currentPlayer === 'O')\n    ) {\n      return;\n    }\n\n         setGameState((prevState: GameState) => updateGameState(prevState, index));\n  }, [gameState, isAIThinking]);\n\n  /**\n   * Start a new game with the specified mode\n   */\n  const newGame = useCallback((mode: GameMode) => {\n    clearSavedGameState();\n    setGameState(createNewGameState(mode));\n    setIsAIThinking(false);\n  }, []);\n\n  /**\n   * Reset the current game (keep same mode)\n   */\n  const resetGame = useCallback(() => {\n    clearSavedGameState();\n    setGameState((prevState: GameState) => createNewGameState(prevState.gameMode));\n    setIsAIThinking(false);\n  }, []);\n\n  /**\n   * Set the game mode\n   */\n  const setGameMode = useCallback((mode: GameMode) => {\n    setGameState((prevState: GameState) => ({\n      ...prevState,\n      gameMode: mode\n    }));\n  }, []);\n\n  /**\n   * Go back to menu\n   */\n  const goToMenu = useCallback(() => {\n    setGameMode('menu');\n  }, [setGameMode]);\n\n  /**\n   * Get the winning line for highlighting\n   */\n  const winningLine = getWinningLine(gameState.board);\n\n  return {\n    gameState,\n    isAIThinking,\n    winningLine,\n    makeMove,\n    newGame,\n    resetGame,\n    setGameMode,\n    goToMenu,\n  };\n};\n\nexport default useGame; ",
          "language": "typescript",
          "description": "Main content of core/hooks/useGame.ts",
          "order": 0,
          "file": "core/hooks/useGame.ts",
          "meta": {
            "segmentType": "other",
            "startLine": 1,
            "endLine": 135
          }
        }
      ]
    },
    {
      "path": "core/hooks/useStats.ts",
      "name": "useStats.ts",
      "description": "",
      "codeBlocks": [
        {
          "id": "block_47094887",
          "type": "code",
          "content": "// Custom Hook for Game Statistics Management\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { GameStats, Player, GameMode } from '@core/types';\n\nimport {\n  loadGameStats,\n  updateGameStats as updateGameStatsUtil,\n  resetGameStats as resetGameStatsUtil,\n  formatGameStats\n} from '@core/game/utils';\n\nexport const useStats = () => {\n  const [stats, setStats] = useState<GameStats>(loadGameStats());\n\n  // Load stats on mount\n  useEffect(() => {\n    setStats(loadGameStats());\n  }, []);\n\n  /**\n   * Update statistics after a game ends\n   */\n  const updateStats = useCallback((winner: Player | null, gameMode: GameMode) => {\n    if (gameMode === 'menu') return;\n    \n    setStats((prevStats: GameStats) => \n      updateGameStatsUtil(prevStats, winner, gameMode as 'ai' | 'player')\n    );\n  }, []);\n\n  /**\n   * Reset all statistics\n   */\n  const resetStats = useCallback(() => {\n    const newStats = resetGameStatsUtil();\n    setStats(newStats);\n  }, []);\n\n  /**\n   * Get formatted statistics for display\n   */\n  const formattedStats = formatGameStats(stats);\n\n  return {\n    stats,\n    formattedStats,\n    updateStats,\n    resetStats,\n  };\n};\n\nexport default useStats; ",
          "language": "typescript",
          "description": "Main content of core/hooks/useStats.ts",
          "order": 0,
          "file": "core/hooks/useStats.ts",
          "meta": {
            "segmentType": "other",
            "startLine": 1,
            "endLine": 53
          }
        }
      ]
    }
  ],
  "created": "2025-07-06T04:38:07.196Z"
}